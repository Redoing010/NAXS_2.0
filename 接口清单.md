# NAXS Market Data API (Backend-first, Frontend-Ready)

一个“先后端、后前端”的可运行骨架：
- ✅ 提供稳定的实时/分钟级数据接口
- ✅ 统一字段口径与分页/排序
- ✅ 预留所有你列出的功能路由（未实现时返回 501），便于前端直接对接
- ✅ CORS、健康检查、错误处理
- ✅ Docker 部署 & 环境变量配置

> Python 3.10+；FastAPI；AkShare；Uvicorn。

---

## 目录结构
```
market-api/
├─ app/
│  ├─ __init__.py
│  ├─ config.py
│  ├─ cache.py
│  ├─ schemas.py
│  ├─ utils.py
│  ├─ deps.py
│  ├─ main.py
│  └─ routers/
│     ├─ health.py
│     ├─ spot.py              # 实时快照（已实现：/api/spot）
│     ├─ minute.py            # 分钟K（已实现：/api/minute）
│     ├─ placeholders.py      # 其他接口“预留路由”，统一 501
│     └─ __init__.py
├─ requirements.txt
├─ Dockerfile
├─ .env.example
└─ README.md
```

---

## app/config.py
```python
from pydantic import BaseSettings, Field

class Settings(BaseSettings):
    APP_NAME: str = "NAXS Market Realtime API"
    API_PREFIX: str = "/api"

    # CORS
    CORS_ORIGINS: str = "*"

    # Cache TTLs (seconds)
    TTL_SPOT_ALL: float = 4.0
    TTL_MINUTE: float = 2.5

    # Pagination defaults
    DEFAULT_PAGE_SIZE: int = 100
    MAX_PAGE_SIZE: int = 200

    class Config:
        env_file = ".env"

settings = Settings()
```

## app/cache.py
```python
import time
from typing import Any, Dict, Optional

_CACHE: Dict[str, Dict[str, Any]] = {}

def get_cache(key: str, ttl: float) -> Optional[Any]:
    node = _CACHE.get(key)
    if not node:
        return None
    if time.time() - node["ts"] <= ttl:
        return node["data"]
    return None

def set_cache(key: str, data: Any) -> None:
    _CACHE[key] = {"ts": time.time(), "data": data}
```

## app/schemas.py
```python
from typing import List, Optional
from pydantic import BaseModel, Field

class SpotRow(BaseModel):
    symbol: str
    name: str
    price: Optional[float] = None
    pct_chg: Optional[float] = None
    chg: Optional[float] = None
    vol: Optional[float] = None
    amount: Optional[float] = None
    amplitude: Optional[float] = None
    high: Optional[float] = None
    low: Optional[float] = None
    open: Optional[float] = None
    prev_close: Optional[float] = None
    pe_ttm: Optional[float] = None
    turnover_rate: Optional[float] = None
    volume_ratio: Optional[float] = None
    market_cap: Optional[float] = None
    float_market_cap: Optional[float] = None
    list_date: Optional[str] = None

class SpotPage(BaseModel):
    total: int
    page: int
    page_size: int
    rows: List[SpotRow]

class MinuteRow(BaseModel):
    datetime: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    amount: float

class MinuteResp(BaseModel):
    symbol: str
    rows: List[MinuteRow]
```

## app/utils.py
```python
import pandas as pd
from typing import Dict

SPOT_COLS_MAP: Dict[str, str] = {
    "代码": "symbol",
    "名称": "name",
    "最新价": "price",
    "涨跌幅": "pct_chg",
    "涨跌额": "chg",
    "成交量": "vol",
    "成交额": "amount",
    "振幅": "amplitude",
    "最高": "high",
    "最低": "low",
    "今开": "open",
    "昨收": "prev_close",
    "市盈率-动态": "pe_ttm",
    "换手率": "turnover_rate",
    "量比": "volume_ratio",
    "总市值": "market_cap",
    "流通市值": "float_market_cap",
    "上市时间": "list_date",
}

MINUTE_COLS_MAP: Dict[str, str] = {
    "时间": "datetime",
    "开盘": "open",
    "收盘": "close",
    "最高": "high",
    "最低": "low",
    "成交量": "volume",
    "成交额": "amount",
}

def normalize_columns(df: pd.DataFrame, mapping: Dict[str, str]) -> pd.DataFrame:
    return df.rename(columns={c: mapping.get(c, c) for c in df.columns})

def to_numeric(df: pd.DataFrame, cols):
    for col in cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")
    return df
```

## app/deps.py
```python
from fastapi import Query
from .config import settings

def pagination(
    page: int = Query(1, ge=1),
    page_size: int = Query(settings.DEFAULT_PAGE_SIZE, ge=10, le=settings.MAX_PAGE_SIZE),
):
    return {"page": page, "page_size": page_size}
```

## app/routers/health.py
```python
from fastapi import APIRouter

router = APIRouter(tags=["health"])

@router.get("/health")
async def health():
    return {"status": "ok"}
```

## app/routers/spot.py
```python
import pandas as pd
import akshare as ak
from fastapi import APIRouter, Query, Depends
from ..config import settings
from ..cache import get_cache, set_cache
from ..utils import normalize_columns, to_numeric, SPOT_COLS_MAP
from ..schemas import SpotPage
from ..deps import pagination

router = APIRouter(prefix=f"{settings.API_PREFIX}", tags=["spot"])

@router.get("/spot", response_model=SpotPage)
def get_spot(
    sort_by: str = Query("amount"),
    descending: bool = Query(True),
    pg=Depends(pagination),
):
    cache_key = "spot_all"
    df = get_cache(cache_key, settings.TTL_SPOT_ALL)
    if df is None:
        raw = ak.stock_zh_a_spot()  # 新浪全市场快照
        df = normalize_columns(raw, SPOT_COLS_MAP)
        df = to_numeric(
            df,
            ["price","pct_chg","chg","vol","amount","amplitude","high","low","open","prev_close","pe_ttm","turnover_rate","volume_ratio","market_cap","float_market_cap"],
        )
        set_cache(cache_key, df)

    if sort_by in df.columns:
        df = df.sort_values(sort_by, ascending=not descending)

    start = (pg["page"] - 1) * pg["page_size"]
    end = start + pg["page_size"]
    page_df = df.iloc[start:end]

    return {
        "total": int(len(df)),
        "page": pg["page"],
        "page_size": pg["page_size"],
        "rows": page_df.to_dict(orient="records"),
    }
```

## app/routers/minute.py
```python
import akshare as ak
from fastapi import APIRouter, Query
from ..config import settings
from ..cache import get_cache, set_cache
from ..utils import normalize_columns, MINUTE_COLS_MAP
from ..schemas import MinuteResp

router = APIRouter(prefix=f"{settings.API_PREFIX}", tags=["minute"])

@router.get("/minute", response_model=MinuteResp)
def get_minute(
    symbol: str = Query(..., description="6位代码，如 000001"),
    period: str = Query("1", description="1/5/15/30/60 分钟"),
    adjust: str = Query("qfq", description="qfq/hfq/None"),
    limit: int = Query(240, ge=10, le=2000),
):
    cache_key = f"min_{symbol}_{period}_{adjust}"
    df = get_cache(cache_key, settings.TTL_MINUTE)

    if df is None:
        df = ak.stock_zh_a_hist_min_em(symbol=symbol, period=period, adjust=adjust)
        df = normalize_columns(df, MINUTE_COLS_MAP).tail(limit)
        set_cache(cache_key, df)

    return {"symbol": symbol, "rows": df.to_dict(orient="records")}
```

## app/routers/placeholders.py
```python
from fastapi import APIRouter, HTTPException
from ..config import settings

router = APIRouter(prefix=f"{settings.API_PREFIX}", tags=["placeholders"])

# 统一的 501 未实现响应
def not_implemented(name: str):
    raise HTTPException(status_code=501, detail=f"{name} not implemented yet")

# === 你列出的接口，一律先占位，后续逐步落地 ===
@router.get("/board/concept/list")
async def board_concept_list():
    not_implemented("stock_board_concept_name_em")

@router.get("/board/concept/constituents")
async def board_concept_cons():
    not_implemented("stock_board_concept_cons_em")

@router.get("/board/concept/spot")
async def board_concept_spot():
    not_implemented("stock_board_concept_spot_em")

@router.get("/board/industry/list")
async def board_industry_list():
    not_implemented("stock_board_industry_name_em")

@router.get("/board/industry/constituents")
async def board_industry_cons():
    not_implemented("stock_board_industry_cons_em")

@router.get("/board/industry/spot")
async def board_industry_spot():
    not_implemented("stock_board_industry_spot_em")

@router.get("/hsgt/fundflow")
async def hsgt_fundflow():
    not_implemented("stock_hsgt_fundflow")

@router.get("/hsgt/hold")
async def hsgt_hold():
    not_implemented("stock_hsgt_hold_stock")

@router.get("/dividend/em")
async def dividend_em():
    not_implemented("stock_dividend_em")

@router.get("/dividend/ths")
async def dividend_ths():
    not_implemented("stock_dividend_ths")

@router.get("/disclosure")
async def disclosure():
    not_implemented("stock_info_disclosure / yjbb / yjyg")

@router.get("/fundflow/ths")
async def fundflow_ths():
    not_implemented("stock_individual_fund_flow_ths, stock_market_fund_flow_ths")

@router.get("/fundflow/em")
async def fundflow_em():
    not_implemented("stock_individual_fund_flow_em, stock_market_fund_flow_em")

@router.get("/valuations/pe")
async def valuations_pe():
    not_implemented("stock_a_all_pe")

@router.get("/valuations/pb_equal_weight")
async def valuations_pb_equal():
    not_implemented("stock_a_equal_weight_pb")

@router.get("/valuations/median")
async def valuations_median():
    not_implemented("stock_a_median_pe_pb")

@router.get("/buffett")
async def buffett_index():
    not_implemented("stock_buffett_index")

@router.get("/risk_premium")
async def risk_premium():
    not_implemented("stock_risk_premium")

@router.get("/margin/em")
async def margin_em():
    not_implemented("stock_margin_em")

@router.get("/esg/rating")
async def esg_rating():
    not_implemented("stock_esg_rating_em")

@router.get("/esg/full")
async def esg_full():
    not_implemented("stock_esg_full_em")

@router.get("/esg/green_bonds")
async def esg_green():
    not_implemented("stock_green_bond_em")
```

## app/routers/__init__.py
```python
# 空文件用于包导入
```

## app/main.py
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .config import settings
from .routers import health, spot, minute, placeholders

app = FastAPI(title=settings.APP_NAME, version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[settings.CORS_ORIGINS],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(health.router)
app.include_router(spot.router)
app.include_router(minute.router)
app.include_router(placeholders.router)

# 根路由重定向到文档
@app.get("/")
async def root():
    return {"name": settings.APP_NAME, "docs": "/docs"}
```

## requirements.txt
```
akshare==1.12.99
fastapi==0.114.0
uvicorn[standard]==0.30.6
pydantic==1.10.15
pandas==2.2.2
orjson==3.10.7
```

> 备注：若在国内环境，建议自行配置网络或镜像源；AkShare 版本可按你当前环境调整。

## Dockerfile
```dockerfile
FROM python:3.10-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

COPY app ./app

EXPOSE 3001
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "3001", "--workers", "1"]
```

## .env.example
```
APP_NAME=NAXS Market Realtime API
API_PREFIX=/api
CORS_ORIGINS=*
TTL_SPOT_ALL=4.0
TTL_MINUTE=2.5
DEFAULT_PAGE_SIZE=100
MAX_PAGE_SIZE=200
```

## README.md（使用说明）
```md
# NAXS Market Data API (Backend-first)

## 本地运行
```bash
pip install -r requirements.txt
uvicorn app.main:app --host 0.0.0.0 --port 3001 --reload
```

打开文档：`http://localhost:3001/docs`

## Docker 运行
```bash
docker build -t naxs-market-api .
docker run --rm -p 3001:3001 --env-file .env naxs-market-api
```

## 已实现接口
- `GET /api/spot` —— 全市场快照（分页+排序）
- `GET /api/minute` —— 单只分钟K（period: 1/5/15/30/60, adjust: qfq/hfq/None）
- `GET /health`

## 预留接口（501 Not Implemented）
- 行业/概念板块、沪深港通、分红、公告、资金流、估值、ESG 等

## 示例调用

### 1) 榜单（成交额Top，分页）
```bash
curl "http://localhost:3001/api/spot?sort_by=amount&descending=true&page=1&page_size=100"
```

### 2) 分钟K（平安银行 000001, 1分钟分时）
```bash
curl "http://localhost:3001/api/minute?symbol=000001&period=1&adjust=qfq&limit=240"
```

## 性能与稳定建议
- 全市场快照设置 4s 级缓存；
- 自选股未来可改用 WebSocket 推送，减少轮询；
- 异常时保留上次缓存，返回 200 + `stale` 字段（可在后续扩展）；
- 商业化请遵守数据源条款，必要时申请正式授权。
```



---

# Qlib 集成版（数据层 → API → Qlib bundle）

下面把你给出的数据层规范与我之前的 API 骨架**打通**。目标：
1) **AKShare → Parquet（分区 & 增量）**；
2) **DQ 报告**；
3) **Parquet → Qlib bundle**；
4) **API 直接读 Parquet（稳定）**，必要时融合少量**实时补点**；
5) 所有路径、字段、时区与 `schema.md / data-dictionary.md` 完全一致。

## 目录（合并版）
```
repo/
  modules/
    data/
      __init__.py
      interfaces.py
      akshare_source.py
      calendar.py
      parquet_store.py
      dq.py
      qlib_writer.py
      utils.py
  ops/
    pull_prices.py
    build_qlib_bundle.py
    dq_report.py
    sync_oss.py           # 可选
  configs/
    data.yaml
    logging.yaml
  reports/
    dq/
  app/                   # API（沿用之前 FastAPI 项）
    routers/
      health.py
      spot.py            #（实时榜单，来自新浪；可选保留）
      minute.py          #（分钟K，来自东财；可选保留）
      bars.py            # ✅ 新增：直接读 Parquet（权威口径）
      admin.py           # ✅ 新增：触发构建/刷新任务（受 auth 保护）
      placeholders.py
    main.py
  docs/
    schema.md
    data-dictionary.md
  pyproject.toml
  README.md
```

## 关键约定
- **权威数据源**：策略/回测/对外 API 的主数据来自 **Parquet 仓**（落地后的一致口径）。
- **实时性增强**：可选地用 `ak.stock_zh_a_spot()` 补“最新价/涨跌幅”等 **volatile 字段**，与 Parquet 合并输出（软实时），并带 `realtime_ts` 与 `stale` 标记。
- **时区**：落盘与 API 返回均以 **UTC tz-aware index**；前端展示时转换为本地时区。

---

## 新增：/api/bars（读 Parquet 的权威接口）
> 统一给前端/策略使用；与 Qlib/Backtrader 均易对接。

```python
# app/routers/bars.py
from fastapi import APIRouter, Query
from ..config import settings
from modules.data.parquet_store import read_code
from modules.data.utils import map_stock_code

router = APIRouter(prefix=f"{settings.API_PREFIX}", tags=["bars"]) 

@router.get("/bars")
def get_bars(
    code: str = Query(..., description="如 000831.SZ"),
    start: str = Query(..., description="YYYY-MM-DD"),
    end: str = Query(..., description="YYYY-MM-DD"),
    freq: str = Query("D", description="暂仅 D"),
):
    code = map_stock_code(code)
    df = read_code(code, start, end, root=settings.PARQUET_ROOT, freq=freq)
    rows = (
        df.reset_index()
          .rename(columns={df.index.name: "datetime"})
          .to_dict(orient="records")
    )
    return {"code": code, "freq": freq, "rows": rows}
```

> 在 `app/main.py` 中注册：
```python
from .routers import bars
app.include_router(bars.router)
```

> 在 `app/config.py` 增加：
```python
from pydantic import BaseSettings
class Settings(BaseSettings):
    ...
    PARQUET_ROOT: str = "data/parquet"  # 供 /api/bars 使用
```

---

## 新增：/api/admin 任务编排（受 auth）
> 方便你在服务器上一键触发 **拉取 → DQ → 生成 Qlib**（可接入 Celery/RQ，当前为同步 MVP）。

```python
# app/routers/admin.py
import subprocess
from fastapi import APIRouter, HTTPException, Query
from ..config import settings

router = APIRouter(prefix=f"{settings.API_PREFIX}/admin", tags=["admin"]) 

@router.post("/pull")
def pull_prices(codes: str = Query("600519.SH,000831.SZ"), start: str = Query(...), end: str = Query(...)):
    cmd = [
        "python", "ops/pull_prices.py",
        "--market", "stock",
        "--start", start, "--end", end,
        "--out", settings.PARQUET_ROOT,
    ] + sum([["--codes", c] for c in codes.split(",")], [])
    try:
        out = subprocess.check_output(cmd, text=True)
        return {"ok": True, "stdout": out}
    except subprocess.CalledProcessError as e:
        raise HTTPException(500, detail=e.output)

@router.post("/dq")
def dq_report(codes: str, start: str, end: str, out_dir: str = "reports/dq/latest"):
    cmd = [
        "python", "ops/dq_report.py", "--start", start, "--end", end,
        "--freq", "D", "--parquet-root", settings.PARQUET_ROOT,
        "--out", out_dir,
    ] + sum([["--codes", c] for c in codes.split(",")], [])
    try:
        out = subprocess.check_output(cmd, text=True)
        return {"ok": True, "stdout": out}
    except subprocess.CalledProcessError as e:
        raise HTTPException(500, detail=e.output)

@router.post("/qlib/build")
def build_qlib(start: str, end: str, qlib_out: str = "data/qlib_cn_daily"):
    cmd = [
        "python", "ops/build_qlib_bundle.py",
        "--start", start, "--end", end,
        "--parquet-root", settings.PARQUET_ROOT,
        "--qlib-out", qlib_out,
    ]
    try:
        out = subprocess.check_output(cmd, text=True)
        return {"ok": True, "stdout": out}
    except subprocess.CalledProcessError as e:
        raise HTTPException(500, detail=e.output)
```

> 在 `app/main.py` 中注册：
```python
from .routers import admin
app.include_router(admin.router)
```

> 简易鉴权（示例）：
- 在 `Settings` 中加入 `ADMIN_TOKEN`，用 `X-Admin-Token` 头校验；生产可换成 OAuth/JWT。

---

## 实时性策略（融合 Parquet + 实时快照，可选）
- **稳定字段**（open/high/low/close/volume/amount）→ 一律来自 **Parquet**；
- **易变字段**（最新价、涨跌幅等）→ 通过 `ak.stock_zh_a_spot()` 拉取**自选少量标的**，在返回 JSON 中附加：
  ```json
  { "code": "000831.SZ", "realtime": { "price": 10.23, "pct_chg": -0.45, "ts": 1726612345000 }, "stale": false }
  ```
- **限流与容错**：失败时仅返回 Parquet 字段，`stale=true`。前端 UI 用小黄点提示“延迟数据”。

---

## Qlib 构建与验证
- `python ops/build_qlib_bundle.py --start 2018-01-01 --end 2025-09-17 --parquet-root data/parquet --qlib-out data/qlib_cn_daily`
- Qlib 侧验证（脚本略）：使用 `qlib.init(provider_uri="data/qlib_cn_daily")` 后读取样本特征，确保日历、instruments、features 可用。

---

## WBS / DoD（覆盖你给出的 0)~10)）
- **B1 接口抽象**：`IDataSource` + `AkshareSource`；10 支样本 OK。
- **B2 数据字典**：`docs/schema.md`、`data-dictionary.md` 与实际产出一致。
- **B3 缓存/增量**：`parquet_store.write_daily` 分区写入；二次运行仅写新分区。
- **B4 质量规则**：`reports/dq/*/report.md` 生成；异常样例可定位。
- **Qlib 适配**：`qlib_writer.*` 写出 `calendars/`、`instruments/`、`features/`；能被 Qlib 读取。
- **API 对齐**：`/api/bars` 返回字段与时区严格一致；`/api/admin/*` 可触发流水线。

---

## 立即可测（无前端）
```bash
# 1) 拉取并落盘（两只示例）
python ops/pull_prices.py --market stock --codes 000831.SZ --codes 600519.SH \
  --start 2020-01-01 --end 2025-09-17 --freq D --out data/parquet

# 2) 启动 API（确保 Settings.PARQUET_ROOT 指向 data/parquet）
uvicorn app.main:app --host 0.0.0.0 --port 3001 --reload

# 3) 读取权威数据（供前端或回测）
curl "http://localhost:3001/api/bars?code=000831.SZ&start=2024-01-01&end=2024-12-31&freq=D"

# 4) 构建 Qlib（可选）
curl -X POST "http://localhost:3001/api/admin/qlib/build?start=2018-01-01&end=2025-09-17&qlib_out=data/qlib_cn_daily"
```

---

## 之后的增强
- **分钟级 Parquet**：新增 `freq=1m/5m` 分区 & 写入；
- **回测直连**：提供 `/api/bars.csv` 导出，或 Arrow Flight / DuckDB HTTP；
- **任务队列**：用 RQ/Celery + Redis；
- **OSS 冷备**：实现 `sync_oss.py`（MD5 清单去重）。

